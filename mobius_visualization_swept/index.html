<!DOCTYPE html>
<html>

<head>
  <meta http-equiv='Content-Type' content='text/html' charset='utf-8' />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>M&ouml;bius bands</title>
  <link href='utils/3M_favicon.png' rel='icon'>
  <link rel='stylesheet' type='text/css' href='utils/kN.css'>
  <link rel="stylesheet" href='utils/shepherd.css'>
  <script src='utils/babylon.custom.js'></script>

  <script src='utils/util.js'></script>
  <script src='utils/tetToggler.js'></script>
  <script src='utils/global_variable.js'></script>
  <script src='utils/kN3.js'></script>
  <script src='utils/data_lower_envelope.js'></script>

  <script src='utils/chart.umd.js' defer></script>
  <script src='utils/mathjax_min.js' defer></script>
  <!-- <script src='utils/animated-cursor.js' defer></script> -->

  <script src="https://unpkg.com/animated-cursor@1.1.1/dist/index.umd.js"></script>

  <!-- Shepherd.js JavaScript -->
  <script src='utils/shepherd.js'></script>
  <script src='utils/tour.js'></script>

  
</head>

<body>
  <!-- <div id="chartLegend" class="chart-legend"></div> -->

  <div class="cursor"></div>
  <script>
    const cursor = document.querySelector('.cursor');

    document.addEventListener('mousemove', e => {
      cursor.setAttribute("style", "top: " + (e.pageY - 10) + "px; left: " + (e.pageX - 10) + "px;")
    })

    document.addEventListener('click', () => {
      cursor.classList.add("expand");

      setTimeout(() => {
        cursor.classList.remove("expand");
      }, 500)
    })

  </script>

  <div class='leftbar'>

    <svg width='200' height='110' viewBox='-100 -55 200 110' style='margin-top:10px'>
      <g class='touchElement glow-effect' id='buttNumOfTetMinus'>
        <title>decrease the number n of half twists of the optimal band with n fold rotational symmetry</title>
        <circle cx='-62' cy='10' r='34' /> <!-- Modified cy here -->
        <polygon points='-80 7 -80 13 -44 13 -44 7' fill='#fff' /> <!-- Adjusted y values in points -->
      </g>
      <g class='touchElement glow-effect' id='buttNumOfTetPlus'>
        <title>increase the number n of half twists of the optimal band with n fold rotational symmetry</title>
        <circle cx='62' cy='10' r='34' /> <!-- Modified cy here -->
        <polygon points='80 7 80 13 65 13 65 28 59 28 59 13 44 13 44 7 59 7 59 -8 65 -8 65 7' fill='#fff' />
        <!-- Adjusted y values in points -->
      </g>
      <g class="textElement" id='infoTet'>
        <text y='-40'>number of half twists</text>
        <text id='infoNumOfTet' y='16'>3</text>
      </g>
    </svg>


    <svg id='playSVG' width='200' height='200' viewBox='-60 -60 120 120' style='margin-top:10px'>
      <g class='touchElement glow-effect' id='buttPlayPause'>
        <title> click to play the everting motion</title>
        <circle cx='0' cy='0' r='20' />
        <polygon id='playPausePoly' points='-7 -10 -7 10 13 0' fill='#fff' />
      </g>
      <g class='touchElement  ' id='clockRing'>
        <title> drag to evert the band</title>
        <circle cx='0' cy='0' r='0' fill='none' stroke='#555' stroke-width='26' />
        <circle id='clockHand' r='0' fill='#fff' />
      </g>
    </svg>

    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" style="height:0; width:0; position:absolute;">
      <defs>
        <filter id="colorful-glow">
          <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" />
          <feOffset in="blur" dx="0" dy="0" result="offsetBlur" />
          <feFlood flood-color="#FF7300" result="flood" />
          <feComposite in="flood" in2="offsetBlur" operator="in" result="colorBlur" />
          <feMerge>
            <feMergeNode in="colorBlur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
    </svg>



    <svg id='speedSlider' class='slider glow-effect' width='200' height='100' viewBox='-100 -25 200 50'>
      <title> slide to change the speed of eversion</title>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg>

    <svg id='hingeLengthSlider' class='slider glow-effect' width='200' height='100' viewBox='-100 -25 200 50'>
      <title> slide to change the width of the band</title>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg>

  </div>

  <div class='rightbar'>
    <button class='button' id='buttFullScreen' title='enable full screen'> full screen </button>
    <br>
    <br>
    
    <g class="textElement">

      <text> swept volume </text>
    </g>
    <!-- eversion path of the edge  -->
    <button class='button' id='buttShowEdge' title='path traced by a point on the midline
    of the band  during the everting motion'> edge volume </button>
<!-- eversion path of the edge  -->
<button class='button' id='buttShowMidVol' title='path traced by a point on the midline
of the band  during the everting motion'> midline volume </button>
    <br>
    <!-- eversion path of the midline -->
    <button class='button' id='buttShowMid' title='path traced by a point on the midline
    of the band  during the everting motion'> eversion path </button>
    <button class='button' id='buttShowUnit' title='show 1/n th of the band with n half twists '> show unit </button>
    <!-- <button class='button' id='buttShowAxis'> show axis </button> -->
    <br>
    <br>
    <!-- <g class="textElement">

      <text> physics </text>
    </g> -->

    <button class='button' id="buttShowEnergy"
      title='dimensionless torsion of the midline versus dimensionless bending energy of the stable bands. click on the plot to change the torsion'>
      bending energy</button>
    <button class='button' id="buttShowKappa"
      title='curvature of the midline. the rainbow color corresponds to the arclength. the n red dots are evenly spaced points on the band with n half twists'>
      midline curvature</button>

    <br>
    <br>
    <g class="textElement">

      <text> colors </text>
    </g>
    <button class='button' id='buttColor1' title='ranbow color scheme for the surface of the band'> rainbow </button>
    <button class='button' id='buttColor2' title='two faces of the band colored with white and red'> digital </button>
    <!-- <button class='button' id='buttColor3'> M&ouml;bius rainbow 3 </button>
    <button class='button' id='buttColor4'> digital </button>
    <button class='button' id='buttColor5'> M&ouml;bius BRW 3 </button> -->


    <button class='button' id="backgroundButton"
      title='change the background color for the best visibility using picker on the left-top'>background Color</button>
    <input type="color" id="colorPicker" style="display: none;">

    <!-- <input class="jscolor" value="ab2567" data-jscolor="{format:'rgba', position:'right', width:181, height:101}"> -->
    <br>
    <br>
    <g class="textElement">
      <text> view angle </text>
    </g>
    <button class='button' id='buttAlignAxis' title='align the view with the axis of symmetry'> align axis </button>
    <button class='button' id='buttAlignPlane' title='align the view with the best fit plane'> align plane </button>

  </div>

  <div class="container">
    <div class="content">
      <canvas id='renderCanvas' touch-action='none'></canvas>
      <img src='utils/dragon_oist.svg' style='height:40px;position:absolute;left:0;bottom:0;margin:10px'>
      <img src='utils/3M_white.svg' style='height:40px;position:absolute;right:0;bottom:0;margin:10px'>
    </div>
  </div>
  <div class="contentE">
    <canvas id='renderCanvasE' touch-action='none'></canvas>
    <!-- <canvas id="magnifier"></canvas> -->
  </div>
  <div class="contentK">
    <canvas id='renderCanvasK' touch-action='none'></canvas>
  </div>


  </div>

  <div id="animatedCursor"></div>


  <div id="tourModal" class="modal-backdrop">
    <div class="modal-content">
      <h2>Welcome!</h2>
      <p>Would you like a guided tour of the application?</p>
      <button id="startTourBtn" class="modal-button">Start Tour</button>
      <button id="dismissTourBtn" class="modal-button">No Thanks</button>
      <!-- <p> Press c on the keyboard to interrupt the tour.</p> -->
    </div>
  </div>



  <script>

    colEnergy = colEnergy.map(rgb => rgb.map(val => Math.round(val * 255)));
    var contentE = document.querySelector('.contentE');
    var content = document.querySelector('.content');
    var contentK = document.querySelector('.contentK');
    var contentEWidth = contentE.clientWidth;
    var nChanged = new Event('nChanged'); // triggered by plus/minus buttons
    var energyChanged = new Event('energyChanged'); // triggered by plus/minus buttons
    // var N = 240
    var nu_i;
    var plotClicked;


    var yData = Array.from(energy).concat();
    var len_ydata = yData.length;
    var xData = linspace(8.095, 85.4, len_ydata);


    'use strict';


    if (document.documentMode || /Edge/.test(navigator.userAgent)) {
      alert('MICROSOFT ALARM: You are using strange software which may lead to unexpected behavior of the website. Please use a reasonable 21st century browser, like, for example: Chrome, Firefox, Opera, Safari,...');
    }


    // adding default-visible class to the left and right bar so that they are visible when the page is loaded

    document.addEventListener('DOMContentLoaded', function () {


      const elements = document.querySelectorAll('.leftbar .touchElement, .leftbar .slider, .rightbar .touchElement, .rightbar .slider, .leftbar .button, .rightbar .button, .leftbar .textElement, .rightbar .textElement');
      elements.forEach(el => el.classList.add('default-visible'));

      setTimeout(() => {
        elements.forEach(el => el.classList.remove('default-visible'));
      }, 15000);
    });



    window.addEventListener('DOMContentLoaded', function () {

      // get the canvas DOM element
      var canvas = ebID('renderCanvas');

      // load the 3D engine
      var engine = new BABYLON.Engine(canvas, true);

      // createScene function that creates and return the scene
      var createScene = function () {
        // create a basic BJS Scene object
        var scene = new BABYLON.Scene(engine);
 
        scene.useRightHandedSystem = true;
        scene.clearColor = new BABYLON.Color3(0.3254901960784314, 0.396078431372549, 0.3686274509803922);
        // camera Math.PI
        var camera = new BABYLON.ArcRotateCamera('ArcRotateCamera', Math.PI, 0, 1.2, new BABYLON.Vector3.Zero(), scene);
        camera.lowerRadiusLimit = .1;
        camera.upperRadiusLimit = 100;
        camera.wheelPrecision = 100;
        camera.pinchPrecision = 200;
        scene.activeCamera.panningSensibility = 0;
        camera.alpha = 6.185710546084945;
        camera.beta = 1.0989063024750556;
        camera.radius = 3;
        ///////////////////////////////////////////////////////////////////////////////////

        var light = new BABYLON.SpotLight('spotLight', new BABYLON.Vector3(-.0, 1.5, 0), new BABYLON.Vector3(1, 1, 1), Math.PI / 2, .1, scene);
       // var light =  new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(0, -1, 0), scene);
        light.shadowIntensity = 1.0;
        light.shadowBlur = 4;

        // Set the target of the light to be the camera position
        light.setDirectionToTarget(camera.position);
        // light.parent = camera;

       // environment light 
       // Assuming 'scene' is your Babylon.js scene

//   // Load an HDR environment texture
//   var hdrTexture = new BABYLON.HDRCubeTexture("./utils/sunset.hdr", scene, 512);
// scene.environmentTexture = hdrTexture;



        var white = new BABYLON.StandardMaterial('texture1', scene);
        var cyan = new BABYLON.StandardMaterial('texture1', scene);
        var yellow = new BABYLON.StandardMaterial('texture1', scene);
           var edgeColor =  new BABYLON.StandardMaterial('texture1', scene);
        
        var red = new BABYLON.StandardMaterial('texture1', scene);
        var trans = new BABYLON.StandardMaterial('texture1', scene);
        white.diffuseColor = new BABYLON.Color3(1, 1, 1);
        cyan.diffuseColor = new BABYLON.Color3(0, 1, 1);
        yellow.diffuseColor = new BABYLON.Color3(1, 1, 0);
        red.diffuseColor = new BABYLON.Color3(1, 0, 0);
        //cyan.wireframe = true;
        trans.alpha = 0.7;

        var bandMat = new BABYLON.StandardMaterial('texture1', scene);

        bandMat.diffuseColor = new BABYLON.Color3(1, 1, 0);


        // var ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 4, height: 4 }, scene);
        // var groundMaterial = new BABYLON.StandardMaterial('groundMaterial', scene);
        // groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2); // Set a dark color for the ground

        // groundMaterial.specularColor = new BABYLON.Color3(1, 1, 1);; // Disable specular highlights

        // ground.position = new BABYLON.Vector3(0, -.7, 0);

        // ground.material = groundMaterial;


        // Create a new standard material 'glass' 
        var glass = new BABYLON.StandardMaterial("glass", scene);

        // Make it transparent
        glass.alpha = 0.045;
        // Give it a high specular power for glossiness
        glass.specularPower = 100;
        // Give it a low diffusivity so it doesn't scatter light
        glass.diffuseColor = new BABYLON.Color3(1, 1, 1, .1);
        // Set its index of refraction to something like glass
        glass.indexOfRefraction = 1.52;

        //scene.clearColor = new BABYLON.Color3(0, 0, 0);
        //scene.createDefaultSkybox(backgroundTexture, true);



        ///////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////




        // Set the material of the arrow



        var golf = [];



        init_parameters(1);
        data_t0(1);



        var midlineMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        midlineMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        midlineMaterial.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);

        var optionsMidline = [];
        var midline = [];

        // rulings 
        var rulingsMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        rulingsMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        rulingsMaterial.emissiveColor = new BABYLON.Color4(1, 1, 1, 1);

        var optionsRulings = [];
        var rulings = [];



        function midlineInit() {
          // Update the path
          var initialPath = [];
          for (var i = 0; i < N + 1; i++) {
            initialPath.push(new BABYLON.Vector3(0, 0, 0));
          }

          optionsMidline = {
            path: initialPath, //vec3 array,
            radius: 0.004, // set the radius of the tube
            updatable: true
          };
          // Update the tube mesh with the new data
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline, scene);
          midline.material = midlineMaterial;

          // initialize rulings 


          for (var i = 1; i < n + 1; i++) {
            let temp = [];
            temp.push(new BABYLON.Vector3(0, 0, 0));
            temp.push(new BABYLON.Vector3(0, 0, 0));

            optionsRulings = {
              path: temp, //vec3 array,
              radius: 0.01, // set the radius of the tube
              updatable: true
            };

            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings, scene);
            rulings[i].material = rulingsMaterial;


          };

        };
        midlineInit();




        function k_to_t(k) {
          return Math.round(k * N / (2 * Math.PI));
        };
        var t;



        var eversionPlay = new Event('eversionPlay'); // triggered by plus/minus buttons

        var vertexData = [];
        var vertexDataBack = [];
        var band = new BABYLON.Mesh('custom', scene);
        var bandBack = new BABYLON.Mesh('custom', scene);



        function updateBandMesh(k, hingeLength) {
          t = k_to_t(k);
          let temp = fourierExpansion(N, t, hingeLength);
          var v = temp[0];

          // updating curvature 
          kappa = temp[1].concat();
          document.body.dispatchEvent(eversionPlay);


          if (showKappa == true) {
            if (chartK != null) {
              destroyChart(chartK);
            }
            createchartK(kappa);
          }





          // N = 105;
          var pos = [];
          var pathMidline = [];
          var indices = [];
          var indicesBack = [];
          var colors = [];
          var colorsBack = [];

          for (var i = 1; i < N + 1; i++) {
            var v1 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
            var v2 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];



            pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

            // surface 

            pos.push(v1[0], v1[1], v1[2]);
            pos.push(v2[0], v2[1], v2[2]);

            if (colorScheme == 1) {
              var c1 = jet(i - 1);

              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            } else {
              colors.push(1, 1, 1, 1);
              colors.push(1, 1, 1, 1);
              colorsBack.push(1, 0, 0, 1);
              colorsBack.push(1, 0, 0, 1);
            }

            if (i > 0) {
              indices.push(2 * i - 1, 2 * i, 2 * i - 2);
              indices.push(2 * i, 2 * i - 1, 2 * i + 1);

              indicesBack.push(2 * i, 2 * i - 1, 2 * i - 2);
              indicesBack.push(2 * i - 1, 2 * i, 2 * i + 1);

            };
          };

          //   console.log(pathMidline)
          // Update the tube mesh with the new path
          // Remove the existing tube mesh


          i = 1;
          var v2 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
          var v1 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];

          pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

          pos.push(v1[0], v1[1], v1[2]);
          pos.push(v2[0], v2[1], v2[2]);

          if (colorScheme == 1) {
            var c1 = jet(i - 1);

            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
          } else {
            colors.push(1, 1, 1, 1);
            colors.push(1, 1, 1, 1);
            colorsBack.push(1, 0, 0, 1);
            colorsBack.push(1, 0, 0, 1);
          }

          // indicesBack.push(2*N-1, 1, 0);
          // indicesBack.push(2*N-1, 0, 2*N);

          //   indices.push( 0,2*N-1, 2*N);
          //   indices.push( 1,2*N-1, 0);


          var normals = [];
          BABYLON.VertexData.ComputeNormals(pos, indices, normals);

          var vertexData = new BABYLON.VertexData();
          vertexData.positions = pos;
          vertexData.indices = indices;
          vertexData.normals = normals;
          vertexData.colors = colors;

          vertexData.applyToMesh(band);



          var normalsBack = [];
          BABYLON.VertexData.ComputeNormals(pos, indicesBack, normalsBack);
          vertexDataBack = new BABYLON.VertexData();
          vertexDataBack.positions = pos;
          vertexDataBack.indices = indicesBack;
          vertexDataBack.normals = normalsBack;
          vertexDataBack.colors = colorsBack;

          vertexDataBack.applyToMesh(bandBack);

          ///  surface created 

          /// creating midline 

          // Update
          optionsMidline.path = pathMidline;
          optionsMidline.instance = midline;
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline); //No scene parameter when using instance
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);


          if (showUnit) {
            // Enable vertex alpha for the mesh
            band.hasVertexAlpha = true;
            bandBack.hasVertexAlpha = true;

            // Disable backface culling
            //band.backFaceCulling = false;
            //bandBack.backFaceCulling = false;

            var vertexData = band.getVerticesData(BABYLON.VertexBuffer.ColorKind);
            var vertexDataBack = bandBack.getVerticesData(BABYLON.VertexBuffer.ColorKind);

            // Ensure the vertex buffer is large enough to accommodate the modifications
            if (!vertexData || vertexData.length < 4 * (N + 1)) {
              vertexData = new Float32Array(4 * (N + 1));
            }
            if (!vertexDataBack || vertexDataBack.length < 4 * (N + 1)) {
              vertexDataBack = new Float32Array(4 * (N + 1));
            }

            var ind = Math.round(N / n) + 1;
            for (var i = ind; i < N + 1; i++) {
              var j = 2 * i;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 1;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 2;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 3;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;
            }

            // Update the vertex colors with modified alpha values
            band.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexData);
            bandBack.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexDataBack);


          };




          var ind1 = Math.round(N / (2 * n));

          for (var j = 1; j < golf.length + 1; j++) {
            let l = 2 * j * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            if (golf[j]) {
              golf[j].position = new BABYLON.Vector3((v1[0] + v2[0]) / 2,
                (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2);

            };

          };



          var ind1 = Math.round(N / (2 * n));


          // creating rulings 
          for (var i = 1; i < n + 1; i++) {
            // l =  i * ind1   ;
            l = 2 * i * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            let path = [];
            path.push(new BABYLON.Vector3(v1[0], v1[1], v1[2]));
            path.push(new BABYLON.Vector3(v2[0], v2[1], v2[2]));

            optionsRulings.path = path;
            optionsRulings.instance = rulings[i];
            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings); //No scene parameter when using instance


          };

          // meshDispose(golf) 

        };




        // tube paths /////////////////////////////////////////////////////////////////////

        function createTube(tube, type, hingeLength, color) {

          if(type==1){
          var ind0 = Math.round(N / (2 * n));
          for (var i = 1; i < n + 1; i++) {
            var ind = 2 * i * ind0 - 2 * ind0 + 1;

            var curve = paths(n, hingeLength, type, ind);
            tube[i] = BABYLON.Mesh.CreateTube('tube', curve, 0.0025, 8, null, null, scene);
            tube[i].material = color;
            golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
              'ico', { radius: 0.03, subdivisions: 8, flat: false, updatable: false }, scene);
            golf[i].material = red;
            updateBandMesh(k, hl);

          }};

          if(type==2){
            
            for (var t = 1; t < N + 1; ++t) {
              var path = [];
              var v0  = [];
              var v   = [];

              v0  = fourierExpansion(n, t, hl)[0];   // vertex at time stamp t

              for (var i = 1; i < N + 1; ++i){
  
              v[1] = v0[6 * i - 5]; 
              v[2] = v0[6 * i - 4]; 
              v[3] = v0[6 * i - 3]; 
              v[4] = v0[6 * i - 2]; 
              v[5] = v0[6 * i - 1]; 
              v[6] = v0[6 * i  ];  

              path.push(new BABYLON.Vector3(v[1],v[3],-v[2]));
            }
            tube[t] = BABYLON.Mesh.CreateTube('tube', path, 0.0025, 8, null, null, scene);
            
            //var color = generateShadeOfCyan(t, N)
            
            
            //edgeColo.diffuseColor = new BABYLON.Color3(color.r,color.g,color.b);
            edgeColor.diffuseColor = new BABYLON.Color3(1,1,1);
            tube[t].material = edgeColor;

          };
          }


          if(type==3){
            
            for (var t = 1; t < N+1 ; ++t) {
              var path = [];
              var v0  = [];
              var v   = [];

              v0  = fourierExpansion(n, t, hl)[0];   // vertex at time stamp t

              for (var i = 1; i < N + 1; ++i){
  
              v[1] = v0[6 * i - 5]; 
              v[2] = v0[6 * i - 4]; 
              v[3] = v0[6 * i - 3]; 
              v[4] = v0[6 * i - 2]; 
              v[5] = v0[6 * i - 1]; 
              v[6] = v0[6 * i  ];  

              path.push(new BABYLON.Vector3(  (v[1] + v[4]) / 2,
          (v[3] + v[6]) / 2,
          -(v[2] + v[5]) / 2));
            }

            i = 1
            v[1] = v0[6 * i - 5]; 
              v[2] = v0[6 * i - 4]; 
              v[3] = v0[6 * i - 3]; 
              v[4] = v0[6 * i - 2]; 
              v[5] = v0[6 * i - 1]; 
              v[6] = v0[6 * i  ];  

              path.push(new BABYLON.Vector3(  (v[1] + v[4]) / 2,
          (v[3] + v[6]) / 2,
          -(v[2] + v[5]) / 2));


            tube[t] = BABYLON.Mesh.CreateTube('tube', path, 0.0025, 8, null, null, scene);
            
            //var color = generateShadeOfCyan(t, N)
            
            
            //edgeColo.diffuseColor = new BABYLON.Color3(color.r,color.g,color.b);
            edgeColor.diffuseColor = new BABYLON.Color3(1,1,1);
            tube[t].material = edgeColor;

          };
          }

          




          // if (type == 2) { // midpoints get golf
          //   for (var i = 1; i < n + 1; ++i) {
          //     golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
          //       'ico', { radius: 0.03, subdivisions: 8, flat: false, updatable: false }, scene);
          //     golf[i].material = color;
          //   }
          // updateBandMesh(k, hl);
          // }
        }


        // plane //////////////////////////////////////////////////////////////////////////

        function enablePlane(bool) {


        }


        // dispose mesh ///////////////////////////////////////////////////////////////////

        function meshDispose(me) {
          var i = 1;
          while (me[i]) {
            me[i].dispose();
            i += 1;
          }
        }

        function setSliderPosition(newValue) {
          var slider = document.getElementById("energySlider");
          if (slider) {
            slider.value = newValue; // Set the slider value
            // Trigger any event or function associated with the slider's change
          }
        }

        //#################################################################################
        //#################################################################################

        // change number of half twists ////////////////////////////////////////////////////

        ebID('buttNumOfTetMinus').addEventListener('click', function () {
          if (n > 3) {
            n = n - 2;

            // change the position of the energy slider 

            document.body.dispatchEvent(nChanged);

            // document.body.dispatchEvent(nuiChanged);
          }
        });
        ebID('buttNumOfTetPlus').addEventListener('click', function () {
          if (n < 27) {
            n = n + 2;

            document.body.dispatchEvent(nChanged);
            // document.body.dispatchEvent(nuiChanged);
          }
        });


        // show corner/midpoint paths /////////////////////////////////////////////////////

        var showMid = false;

        //#################################################################################
        //#################################################################################





        // document.body.addEventListener('nuiChanged', function (e) {
        //   nuSlider = new Slider('nuSlider', nu_min, nu_max, nu_opt, '&nu;    ', 0, ' ');
        //   ebID('nuSlider').addEventListener('sliderChange', function (e) {
        //     nu_i = parseInt(nuSlider.getValue());
        //      document.body.dispatchEvent(nChanged);
        //     refresh = true;
        //   });

        // }, false);

        /////////////////////////nui changed////////////////////////////

        /////////////////////////n  changed////////////////////////////


        document.body.addEventListener('nChanged', function (e) {
          ebID('infoNumOfTet').innerHTML = n;

          n_to_nui(n)
          // modifying the slider and its limits when n is changed 

          nu_i = nu_opt;

          // change the energy slider 
          setSliderPosition(nu_i);

          init_parameters(nu_i)
          data_t0(nu_i);

          midline.dispose();
          meshDispose(rulings);
          midlineInit();


          if (showMid) {
            meshDispose(tubeMid);
            meshDispose(golf);
            createTube(tubeMid, 1, 0.5 * 3, yellow);
          }
          if (showEdge) {
            meshDispose(tubeEdge);
            meshDispose(golf);
            createTube(tubeEdge, 2, 0.5 * 3, cyan);
          }

          if (showMidVol) {
            meshDispose(tubeMidVol);
            meshDispose(golf);
            createTube(tubeMidVol, 3, 0.5 * 3, cyan);
          }

          updateBandMesh(k, hl);

          refresh = true;
        }, false);

        //plotClicked = new CustomEvent('plotClicked', { detail: { nu_i:nu_i,n:n } });

        function magnify(canvasId, zoom) {
          var canvas = document.getElementById(canvasId);
          var magnifier = document.getElementById("magnifier");
          var magnifierCtx = magnifier.getContext("2d");
          var magnifierDiameter = magnifier.width; // Assuming width and height are the same
          var magnifierRadius = magnifierDiameter / 2;

          function moveMagnifier(e) {
            var canvasRect = canvas.getBoundingClientRect();
            var mouseX = e.clientX - canvasRect.left;
            var mouseY = e.clientY - canvasRect.top;

            // Adjust magnifier position to be centered on cursor
            var magnifierX = e.pageX - magnifierRadius;
            var magnifierY = e.pageY - magnifierRadius;

            // Position the magnifier
            magnifier.style.left = magnifierX - 55 + "px";
            magnifier.style.top = magnifierY + 96 + "px";

            // Clear previous content
            magnifierCtx.clearRect(0, 0, magnifierDiameter, magnifierDiameter);

            // Calculate the zoomed area
            magnifierCtx.drawImage(canvas,
              mouseX * (canvas.width / canvas.offsetWidth) - magnifierRadius / zoom,
              mouseY * (canvas.height / canvas.offsetHeight) - magnifierRadius / zoom,
              magnifierDiameter / zoom, magnifierDiameter / zoom,
              0, 0, magnifierDiameter, magnifierDiameter);
          }

          canvas.addEventListener("mousemove", moveMagnifier);
        }

        // Initialize the magnifier
        //magnify("renderCanvasE", 3); // Adjust the zoom level as needed




        // // Update the canvas position when the window is resized
        // var canvasPosition = document.getElementById('renderCanvasE').getBoundingClientRect();
        // window.addEventListener('resize', debounce(function () {
        //   canvasPosition = document.getElementById('renderCanvasE').getBoundingClientRect();
        // }, 250));

        // // Event listener for the click on renderCanvasE
        // document.getElementById('renderCanvasE').addEventListener('click', function (evt) {
        //   // Calculate the click position relative to the canvas
        //   const clickX = evt.clientX - canvasPosition.left;
        //   const clickY = evt.clientY - canvasPosition.top;

        //   console.log("Canvas clicked at: ", clickX, clickY);

        //   // Chart.js method to find the nearest point
        //   var points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, true);
        //   if (points.length) {
        //     var nearestPoint = points[0];
        //     const dataPoint = chart.data.datasets[nearestPoint.datasetIndex].data[nearestPoint.index];
        //     nu_i = getIndexFromLinspace(dataPoint.x);
        //     nui_to_n(nu_i);

        //     plotClicked = new CustomEvent('plotClicked', { detail: { nu_i: nu_i, n: n } });
        //     document.body.dispatchEvent(plotClicked);

        //     refresh = true;
        //   }
        // });

        function debounce(func, wait) {
          var timeout;
          return function () {
            var context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(function () {
              func.apply(context, args);
            }, wait);
          };
        }



        // Debounce function to limit the rate at which a function can fire
        function debounce(func, wait, immediate) {
          var timeout;
          return function () {
            var context = this, args = arguments;
            var later = function () {
              timeout = null;
              if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
          };
        }



        document.body.addEventListener('plotClicked', function (e) {

          n = e.detail.n;
          nu_i = e.detail.nu_i;


          ebID('infoNumOfTet').innerHTML = n;


          init_parameters(nu_i);
          data_t0(nu_i);
          midline.dispose();
          meshDispose(rulings);
          midlineInit();

          if (showMid) {
            meshDispose(tubeMid);
            meshDispose(golf);
            createTube(tubeMid, 1, 0.5 * 3, yellow);
          }

          if (showEdge) {
            meshDispose(tubeEdge);
            meshDispose(golf);
            createTube(tubeEdge, 2, 0.5 * 3, cyan);
          }

          if (showMidVol) {
            meshDispose(tubeMidVol);
            meshDispose(golf);
            createTube(tubeMidVol, 3, 0.5 * 3, cyan);
          }

          updateBandMesh(k, hl);
          refresh = true;
        }, false);

        // toggle tetrahedra //////////////////////////////////////////////////////////////

        var tetToggled = new Event('tetToggled'); // triggered by tetTogStar
        document.body.addEventListener('tetToggled', function (e) { refresh = true; }, false);

        var tetTogStar = new TetTogStar('tetTogStar', nMax, tetToggled);

        // play controller ////////////////////////////////////////////////////////////////

        var svg = ebID('playSVG');
        var pt = svg.createSVGPoint();
        var dragging = false;
        var clockRing = ebID('clockRing');
        clockRing.addEventListener('mousedown', startDragMouse, false);
        clockRing.addEventListener('touchstart', startDragTouch, false);
        window.addEventListener('mousemove', dragMouse, false);
        window.addEventListener('touchmove', dragTouch, false);
        window.addEventListener('mouseup', stopDrag, false);
        window.addEventListener('touchend', stopDrag, false);
        function startDragMouse(ev) {
          dragging = true;
          if (play) { playIt() };
          dragMouse(ev);
          clockRing.style.opacity = 1;
        }
        function startDragTouch(ev) {
          dragging = true;
          if (play) { playIt() };
          dragTouch(ev);
          clockRing.style.opacity = 1;
        }
        function dragMouse(ev) {
          if (dragging) {
            pt.x = ev.clientX;
            pt.y = ev.clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateBandMesh(k, hl);
            refresh = true;
          }
        }
        function dragTouch(ev) {
          if (dragging) {
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateBandMesh(k, hl);
            refresh = true;
          }
        }
        function stopDrag() {
          dragging = false;
          clockRing.style.opacity = '';
        }
        function playIt() {
          play = !play;
          if (!play) {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 13 0');
          }
          else {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 -2 10 -2 -10 2 -10 2 10 7 10 7 -10 -7 -10');
          }
        };
        ebID('buttPlayPause').addEventListener('click', playIt, false);
        document.addEventListener('keydown', function (e) { if (e.keyCode == '32') playIt(); }); // space key play

        // speed control //////////////////////////////////////////////////////////////////

        var speedSlider = new Slider('speedSlider', 4, 100, 20, 'speed ', 0, '%');
        ebID('speedSlider').addEventListener('sliderChange', function () {
          speedy = speedSlider.getValue() / 2000 / n ** .2;
        });

        // change width/length ////////////////////////////////////////////////////////////

        var hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 20, 'width', 0, '%');
        ebID('hingeLengthSlider').addEventListener('sliderChange', function () {
          hl = hingeLengthSlider.getValue() / 100.0;
          if (!play) updateBandMesh(k, hl);

          if (showEdge) {
            meshDispose(tubeEdge);
            meshDispose(golf);
            createTube(tubeEdge, 2, 0.5 * 3, cyan);
          }
          // if (showMidVol) {
          //   meshDispose(tubeMidVol);
          //   meshDispose(golf);
          //   createTube(tubeMidVol, 3, 0.5 * 3, cyan);
          // }
           
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })


        ///  modifying sliders during the guiding tour 
        ebID('speedSlider').addEventListener('tourSpeed', function () {
          speedSlider = new Slider('speedSlider', 4, 100, 40, 'speed ', 0, '%');
          speedy = 40 / 2000 / n ** .2;
        });

        ebID('speedSlider').addEventListener('tourSpeedBack', function () {
          speedSlider = new Slider('speedSlider', 4, 100, 20, 'speed ', 0, '%');
          speedy = 20 / 2000 / n ** .2;
        });


        ebID('hingeLengthSlider').addEventListener('tourWidth', function () {
          hl = 0.4;
          hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 40, 'width', 0, '%');

          if (!play) updateBandMesh(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })
        ebID('hingeLengthSlider').addEventListener('tourWidthBack', function () {
          hl = 0.2;
          hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 20, 'width', 0, '%');

          if (!play) updateBandMesh(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })

        ////////////////////////////////////////////////////////////////

        // toggle full screen /////////////////////////////////////////////////////////////

        // var ortho = false;
        var fullScreen = false;
        ebID('buttFullScreen').addEventListener('click', function () {
          fullScreen = !fullScreen;
          buttonSwitchColor(ebID('buttFullScreen'), fullScreen);
          toggleFullScreen();
          // ortho = !ortho;
          // if ( ortho ) camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
          // else camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
        });


        // show axis/plane ////////////////////////////////////////////////////////////////





        var showUnit = false;
        ebID('buttShowUnit').addEventListener('click', function () {
          showUnit = !showUnit;
          buttonSwitchColor(ebID('buttShowUnit'), showUnit);





          refresh = true;
        });

        // align to plane/axis ////////////////////////////////////////////////////////////
        var alignPlane = false;
        ebID('buttAlignPlane').addEventListener('click', function () {
          alignPlane = !alignPlane;
          //  buttonSwitchColor(ebID('buttAlignPlane' ), alignPlane);
          camera.alpha = Math.PI;
          camera.beta = Math.PI / 2;
          if (!play) k = 0;
          refresh = true;
        });
        var alignAxis = false;
        ebID('buttAlignAxis').addEventListener('click', function () {
          alignAxis = !alignAxis;
          // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = Math.PI;
          camera.beta = 0;
          if (!play) k = 0;
          refresh = true;
        });

        // changing the camera angle during the tour 
        ebID('renderCanvas').addEventListener('tourCamera', function (event) {
          console.log("enetered rotate camera")
          // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = event.detail.alpha;
          camera.beta = event.detail.beta;
          if (!play) k = 0;
          refresh = true;
        });

        // change surface colors //////////////////////////////////////////////////////////

        var previousColorScheme = colorScheme;
        buttonSwitchColor(ebID('buttColor' + colorScheme), true);

        for (var i = 1; i < maxColor + 1; i++) {
          (function (i) {
            ebID('buttColor' + i).addEventListener('click', function () {
              previousColorScheme = colorScheme;
              colorScheme = i;
              document.body.dispatchEvent(colorChanged);
            });
          }(i));
        }

        var colorChanged = new Event('colorChanged'); // triggered by plus/minus buttons

        document.body.addEventListener('colorChanged', function (e) {
          buttonSwitchColor(ebID('buttColor' + previousColorScheme), false);
          buttonSwitchColor(ebID('buttColor' + colorScheme), true);
          if (!play) updateBandMesh(k, hl);
          refresh = true;
        }, false);


        var tubeMid = [];
        ebID('buttShowMid').addEventListener('click', function () {
          showMid = !showMid;
          buttonSwitchColor(ebID('buttShowMid'), showMid);
          if (showMid) createTube(tubeMid, 1, 0.5 * 3, yellow);
          else {
            meshDispose(tubeMid);
            meshDispose(golf);
          }
          refresh = true;
        });

        var tubeEdge = [];
        var showEdge = false;

        ebID('buttShowEdge').addEventListener('click', function () {
          showEdge = !showEdge;
          buttonSwitchColor(ebID('buttShowEdge'), showEdge);
          if (showEdge) createTube(tubeEdge, 2, 0.5 * 3, cyan);
          else {
            meshDispose(tubeEdge);
            // meshDispose(golf);
          }
          refresh = true;
        });

        var tubeMidVol = [];
        var showMidVol = false;

        ebID('buttShowMidVol').addEventListener('click', function () {
          showMidVol = !showMidVol;
          buttonSwitchColor(ebID('buttShowMidVol'), showMidVol);
          if (showMidVol) createTube(tubeMidVol, 3, 0.5 * 3, cyan);
          else {
            meshDispose(tubeMidVol);
            // meshDispose(golf);
          }
          refresh = true;
        });


        function generateShadeOfCyan(i, N) {
  // Ensure i is within the range [0, N]
  i = Math.max(0, Math.min(i, N));

  // Calculate the fraction representing the position of i within the total N steps
  let fraction = i / N;

  // Start color is white
  let startColor = { r: 1, g: 1, b: 1 };
  // End color is cyan
  let endColor = { r: 0, g: 0, b: 1 };

  // Interpolate between start and end colors
  let r = startColor.r + (endColor.r - startColor.r) * fraction;
  let g = startColor.g + (endColor.g - startColor.g) * fraction;
  let b = startColor.b + (endColor.b - startColor.b) * fraction;

  // Round the results to get whole numbers for RGB values
  r = Math.round(r);
  g = Math.round(g);
  b = Math.round(b);

  return { r, g, b };
}
        ///////////////////////////////////////////////////////////////////////////////////

        camera.attachControl(canvas, false);

        function refreshScene() { refresh = true; } // to prevent freezing of the render window after long inactivity
        setInterval(refreshScene, 1000);





        //#############################################################
        //#############################################################
        scene.registerBeforeRender(function () {
          if (play || k == 0) {
            updateBandMesh(k, hl);
            // move clock hand
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(k));
            dot.setAttribute('cy', -40 * Math.cos(k));
            if (play) k += speedy;
          }
        });
        //#############################################################
        //#############################################################


        // the canvas/window resize event handler
        window.addEventListener('resize', function () { engine.resize(); refresh = true; });

        function rend() {
          scene.render();
        }

        var customRender = function () {
          if (refresh || play ||
            Math.abs(camera.inertialRadiusOffset) > 0 ||
            Math.abs(camera.inertialAlphaOffset) > 0 ||
            Math.abs(camera.inertialBetaOffset) > 0) {
            scene.render();
          }
          if (refresh) refresh = false;
        }
        engine.stopRenderLoop(); // Stop the automatic PG rendering
        rend(); // Render the first frame.
        engine.runRenderLoop(customRender); //start main render loop

        //document.body.addEventListener('nuiChanged', function () { console.log("updated value of nu index is " +  parseInt(nuSlider.getValue()))});





        var showEnergy = false;
        var showKappa = false;
        var showEversionPath = false;




        ebID('buttShowEnergy').addEventListener('click', function () {
          showEnergy = !showEnergy;
          buttonSwitchColor(ebID('buttShowEnergy'), showEnergy);

          if (showEnergy == false) {
            contentK.style.top = '0%';
            contentE.style.height = '0%';
            destroyChart(chart);  // Destroy the chart when showEnergy is false
          } else {
            contentE.style.height = '25%';
            //nu_i = parseInt(nuSlider.getValue());
            createChart(nu_i);
            document.body.addEventListener('nuiChanged', function () {
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);

              if (showKappa == true) {
                contentK.style.top = '25%';
              }

            });
            document.body.dispatchEvent(energyChanged);

            document.body.addEventListener('nChanged', function (e) {
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);
            });
            document.body.addEventListener('plotClicked', function (e) {
              nu_i = e.detail.nu_i;
              n = e.detail.n;
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);
            });

            // Create the chart when showEnergy is true
          }
        });
        // energy changed during the tour


        ////////////////////////////////////////////////////////////////
        // create the chart for curvature 
        ////////////////////////////////////////////////////////////////




        // creating the plot for paths
        //var curve = paths(n, hingeLength, type, ind);




        ebID('buttShowKappa').addEventListener('click', function () {
          showKappa = !showKappa;
          buttonSwitchColor(ebID('buttShowKappa'), showKappa);

          if (showKappa == false) {
            contentK.style.height = '0%';
            destroyChart(chartK);  // Destroy the chartK when showKappa is false
          } if (showKappa == true) {
            if (showEnergy == true) {
              contentK.style.top = '25%';
            }
            contentK.style.height = '22%';
            //  createchartK(kappa);

            document.body.addEventListener('energyChanged', function () {
              contentK.style.top = '25%';
            });


            if (showEnergy === false) {
              contentK.style.top = '0%';
            }





            // Create the chartK when showKappa is true
          }
        });

        function positionSliderAbovePlot(slider, chart) {
          var canvasRect = chart.canvas.getBoundingClientRect();
          var chartArea = chart.chartArea;

          var leftOffset = canvasRect.left + chartArea.left;
          var topOffset = canvasRect.top + chartArea.bottom; // Positioning it just below the x-axis
          var width = chartArea.right - chartArea.left;

          slider.style.position = 'absolute';
          slider.style.left = 15 + '%';
          slider.style.top = 23 + '%';
          slider.style.width = width + 'px';
        }


        function addSlider() {
          var canvas = document.getElementById("renderCanvasE");
          var slider = document.createElement("input");
          slider.setAttribute("type", "range");
          slider.setAttribute("id", "energySlider");
          slider.setAttribute("min", "1");
          slider.setAttribute("max", len_ydata.toString());
          slider.classList.add("energySlider");

          document.body.appendChild(slider);
          positionSliderAbovePlot(slider, chart);

          slider.addEventListener("input", function () {

            // deleting the eversion path for efficiently dragging
            meshDispose(tubeMid);
            meshDispose(golf);
            showMid = false;
            buttonSwitchColor(ebID('buttShowMid'), showMid);

            // updated nu value based on the slider
            nu_i = parseInt(this.value);

            // Convert the value from [0, 100] to [8.095, 85.4]

            nui_to_n(nu_i);

            plotClicked = new CustomEvent('plotClicked', { detail: { nu_i: nu_i, n: n } });
            document.body.dispatchEvent(plotClicked);
            ;
          });
        }

        function removeSlider() {
          var slider = document.getElementById("energySlider");
          if (slider) {
            slider.remove();
          }
        }




        // window.addEventListener("resize", function () {
        //   var slider = document.getElementById("energySlider");
        //   var canvas = document.getElementById("renderCanvasE");
        //   if (slider && canvas) {
        //     positionSliderAbovePlot(slider, canvas);
        //   }
        // });

        ebID("buttShowEnergy").addEventListener('click', function () {
          if (showEnergy) {
            addSlider(); // Add the slider only if showEnergy is true
            // When the slider is created
            var energySlider = document.getElementById('energySlider');
            if (energySlider) {
              // Initially set the opacity to 1
              energySlider.style.opacity = 1;

              // Set a timeout to change the opacity back to 0 after a specified time
              setTimeout(function () {
                energySlider.style.opacity = '';
              }, 2000); // 5000 milliseconds = 5 seconds
            }
          } else {
            removeSlider(); // Remove the slider only if showEnergy is false
          }


        });

        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////


        return scene;
      }

      var scene = createScene(); // call the createScene function

      // Create a custom event
      var openColorPickerEvent = new Event('openColorPicker');


      ebID('backgroundButton').addEventListener('openColorPicker', function () {
        // Trigger the color picker
        ebID('colorPicker').click();
      });

      // Keep the existing 'click' event listener as well
      ebID('backgroundButton').addEventListener('click', function () {
        ebID('colorPicker').click();
      });


      ebID('colorPicker').addEventListener('input', function () {
        // Get the color value from the color picker
        var colorVal = this.value;

        // Convert hex color to RGB
        var r = parseInt(colorVal.substr(1, 2), 16) / 255;
        var g = parseInt(colorVal.substr(3, 2), 16) / 255;
        var b = parseInt(colorVal.substr(5, 2), 16) / 255;

        // Update the scene's background color
        scene.clearColor = new BABYLON.Color3(r, g, b);
      });


    });



    // Start the tour

    // ...add more steps for other buttons...

    // Start the tour
    var showTour = true;
    document.addEventListener('DOMContentLoaded', function () {
    // Show the modal
    ebID('tourModal').style.display = 'block';
});

// Initialize your tour
var tour = new Shepherd.Tour({
    // your tour options and steps
});

window.startTour = function() {
    tour.start();
};

// Function to toggle pause and resume
// Function to toggle pause and resume
var isTourPaused = false;

// Function to toggle pause and resume
function toggleTourPause() {
    if (tour.isActive() && !isTourPaused) {
        tour.cancel();
        isTourPaused = true;
    } else if (isTourPaused) {
        tour.start();
        isTourPaused = false;
    }
}



// Listen for keydown event
document.addEventListener('keydown', function(event) {
    if (event.code === 'KeyC') { // Check if space bar is pressed
      console.log("event cancelled")
        event.preventDefault(); // Prevent the default space bar action
        toggleTourPause(); // Toggle the tour pause/resume
    }
});

// Start tour when "Start Tour" button is clicked
ebID('startTourBtn').addEventListener('click', function () {
    window.startTour();
    ebID('tourModal').style.display = 'none'; // Hide modal
});

// Close modal when "No Thanks" button is clicked
ebID('dismissTourBtn').addEventListener('click', function () {
    ebID('tourModal').style.display = 'none'; // Hide modal
});


    // document.addEventListener('keydown', function(event) {
    //   if (event.key === 'c' || event.key === 'C') {
    //     // Stop the tour
    //     if (tour.isActive()) {
    //       tour.cancel(); // or tour.complete();
    //     }

    //     // Hide the cursor
    //     const cursor = document.querySelector('.cursor');
    //     if (cursor) {
    //       cursor.style.display = 'none';
    //     }
    //   }
    // });




  </script>

</body>

</html>
